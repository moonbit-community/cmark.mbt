// Generated using `moon info`, DON'T EDIT IT
package "moonbit-community/cmark/cmark"

import(
  "moonbit-community/cmark/cmark_base"
  "moonbitlang/core/json"
)

// Values
pub let layout_empty : Node[String]

pub fn layout_of_string(meta? : @cmark_base.Meta, String) -> Node[String]

// Errors
pub(all) suberror FolderError String
pub impl Show for FolderError

pub(all) suberror MapperError String
pub impl Show for MapperError

// Types and methods
pub(all) enum Block {
  BlankLine(Node[String])
  BlockQuote(Node[BlockQuote])
  Blocks(Node[Seq[Block]])
  CodeBlock(Node[CodeBlock])
  Heading(Node[BlockHeading])
  HtmlBlock(Node[HtmlBlock])
  LinkRefDefinition(Node[LinkDefinition])
  List(Node[BlockList])
  Paragraph(Node[BlockParagraph])
  ThematicBreak(Node[BlockThematicBreak])
  ExtMathBlock(Node[CodeBlock])
  ExtTable(Node[Table])
  ExtFootnoteDefinition(Node[Footnote])
}
pub fn Block::defs(Self, init? : Map[String, LabelDef]) -> Map[String, LabelDef]
pub fn Block::empty() -> Self
pub fn Block::meta(Self) -> @cmark_base.Meta
pub fn Block::normalize(Self) -> Self
pub impl Show for Block
pub impl ToJson for Block

pub(all) struct BlockHeading {
  layout : BlockHeadingLayout
  level : Int
  inline : Inline
  id : BlockHeadingId?
}
pub fn BlockHeading::new(id? : BlockHeadingId?, layout? : BlockHeadingLayout, level~ : Int, Inline) -> Self
pub impl Show for BlockHeading
pub impl ToJson for BlockHeading

pub(all) struct BlockHeadingAtxLayout {
  indent : Int
  after_opening : String
  closing : String
}
pub fn BlockHeadingAtxLayout::default() -> Self
pub impl Show for BlockHeadingAtxLayout
pub impl ToJson for BlockHeadingAtxLayout
pub impl @json.FromJson for BlockHeadingAtxLayout

pub(all) enum BlockHeadingId {
  Auto(String)
  Id(String)
}
pub impl Show for BlockHeadingId
pub impl ToJson for BlockHeadingId
pub impl @json.FromJson for BlockHeadingId

pub(all) enum BlockHeadingLayout {
  Atx(BlockHeadingAtxLayout)
  Setext(BlockHeadingSetextLayout)
}
pub impl Show for BlockHeadingLayout
pub impl ToJson for BlockHeadingLayout

pub(all) struct BlockHeadingSetextLayout {
  leading_indent : Int
  trailing_blanks : String
  underline_indent : Int
  underline_count : Node[Int]
  underline_blanks : String
}
pub impl Show for BlockHeadingSetextLayout
pub impl ToJson for BlockHeadingSetextLayout

pub(all) struct BlockLine(Node[String])
#deprecated
pub fn BlockLine::inner(Self) -> Node[String]
pub fn BlockLine::list_text_loc(Seq[Self]) -> @cmark_base.TextLoc
pub fn BlockLine::to_string(Self) -> String

pub(all) struct BlockList {
  ty : @cmark_base.ListType
  tight : Bool
  items : Seq[Node[ListItem]]
}
pub fn BlockList::map_items(Self, (ListItem) -> ListItem) -> Self
pub fn BlockList::normalize_items(Self) -> Self
pub impl Show for BlockList
pub impl ToJson for BlockList

pub(all) struct BlockParagraph {
  leading_indent : Int
  inline : Inline
  trailing_blanks : String
}
pub fn BlockParagraph::new(leading_indent? : Int, trailing_blanks? : String, Inline) -> Self
pub impl Show for BlockParagraph
pub impl ToJson for BlockParagraph

pub(all) struct BlockQuote {
  indent : Int
  block : Block
}
pub fn BlockQuote::map_block(Self, (Block) -> Block) -> Self
pub fn BlockQuote::new(indent? : Int, Block) -> Self
pub fn BlockQuote::normalize_block(Self) -> Self
pub impl Show for BlockQuote
pub impl ToJson for BlockQuote

pub(all) struct BlockThematicBreak {
  indent : Int
  layout : String
}
pub fn BlockThematicBreak::new(indent? : Int, layout? : String) -> Self
pub impl Show for BlockThematicBreak
pub impl ToJson for BlockThematicBreak
pub impl @json.FromJson for BlockThematicBreak

pub(all) struct CodeBlock {
  layout : CodeBlockLayout
  info_string : Node[String]?
  code : Seq[Node[String]]
}
pub fn CodeBlock::language_of_info_string(String) -> (String, String)?
pub fn CodeBlock::make_fence(Self) -> (Char, Int)
pub fn CodeBlock::new(layout? : CodeBlockLayout, info_string? : Node[String]?, Seq[Node[String]]) -> Self
pub impl Show for CodeBlock
pub impl ToJson for CodeBlock

pub(all) struct CodeBlockFencedLayout {
  indent : Int
  opening_fence : Node[String]
  closing_fence : Node[String]?
}
pub fn CodeBlockFencedLayout::default() -> Self
pub impl Show for CodeBlockFencedLayout
pub impl ToJson for CodeBlockFencedLayout

pub(all) enum CodeBlockLayout {
  Indented
  Fenced(CodeBlockFencedLayout)
}
pub impl Show for CodeBlockLayout
pub impl ToJson for CodeBlockLayout

pub(all) struct Doc {
  nl : String
  block : Block
  defs : Map[String, LabelDef]
}
pub fn Doc::empty() -> Self
pub fn Doc::from_string(defs? : Map[String, LabelDef], resolver? : LabelResolverFn, nested_links? : Bool, heading_auto_ids? : Bool, layout? : Bool, locs? : Bool, file? : String, strict? : Bool, String) -> Self
pub fn Doc::new(nl? : String, defs? : Map[String, LabelDef], Block) -> Self
pub impl Show for Doc
pub impl ToJson for Doc

pub(all) struct FoldFn[A, B]((Folder[B], B, A) -> B raise FolderError)
#deprecated
pub fn[A, B] FoldFn::inner(Self[A, B]) -> (Folder[B], B, A) -> B raise FolderError

pub(all) struct Folder[A] {
  inline_ext_default : FoldFn[Inline, A]
  block_ext_default : FoldFn[Block, A]
  inline : FolderFn[Inline, A]
  block : FolderFn[Block, A]
}
pub fn[A] Folder::block_ext_none(Self[A], A, Block) -> A raise FolderError
pub fn[A] Folder::fold_block(Self[A], A, Block) -> A raise FolderError
pub fn[A] Folder::fold_doc(Self[A], A, Doc) -> A raise FolderError
pub fn[A] Folder::fold_inline(Self[A], A, Inline) -> A raise FolderError
pub fn[A] Folder::inline_ext_none(Self[A], A, Inline) -> A raise FolderError
pub fn[A] Folder::new(inline_ext_default? : FoldFn[Inline, A], block_ext_default? : FoldFn[Block, A], inline? : FolderFn[Inline, A], block? : FolderFn[Block, A]) -> Self[A]
pub fn[A, B] Folder::none(Self[A], A, B) -> FolderResult[A]
pub fn[A] Folder::ret(A) -> FolderResult[A]

pub(all) struct FolderFn[A, B]((Folder[B], B, A) -> FolderResult[B])
#deprecated
pub fn[A, B] FolderFn::inner(Self[A, B]) -> (Folder[B], B, A) -> FolderResult[B]

pub(all) enum FolderResult[A] {
  Default
  Fold(A)
}
pub impl[A] Default for FolderResult[A]
pub impl[A : Eq] Eq for FolderResult[A]
pub impl[A : Show] Show for FolderResult[A]
pub impl[A : ToJson] ToJson for FolderResult[A]

pub(all) struct Footnote {
  indent : Int
  label : Label
  defined_label : Label?
  block : Block
}
pub fn Footnote::map_block(Self, (Block) -> Block) -> Self
pub fn Footnote::new(indent? : Int, defined_label? : Label?, Label, Block) -> Self
pub fn Footnote::normalize_block(Self) -> Self
pub impl Show for Footnote
pub impl ToJson for Footnote

pub(all) struct HtmlBlock(Seq[Node[String]])
#deprecated
pub fn HtmlBlock::inner(Self) -> Seq[Node[String]]
pub impl Show for HtmlBlock
pub impl ToJson for HtmlBlock

pub(all) enum Inline {
  Autolink(Node[InlineAutolink])
  Break(Node[InlineBreak])
  CodeSpan(Node[InlineCodeSpan])
  Emphasis(Node[InlineEmphasis])
  Image(Node[InlineLink])
  Inlines(Node[Seq[Inline]])
  Link(Node[InlineLink])
  RawHtml(Node[InlineRawHtml])
  StrongEmphasis(Node[InlineEmphasis])
  Text(Node[String])
  ExtStrikethrough(Node[InlineStrikethrough])
  ExtMathSpan(Node[InlineMathSpan])
}
pub fn Inline::empty() -> Self
pub fn Inline::id(Self, buf? : StringBuilder) -> String
pub fn Inline::is_empty(Self) -> Bool
pub fn Inline::meta(Self) -> @cmark_base.Meta
pub fn Inline::normalize(Self) -> Self
pub fn Inline::to_plain_text(Self, break_on_soft~ : Bool) -> Seq[Seq[String]]
pub impl Eq for Inline
pub impl Show for Inline
pub impl ToJson for Inline

pub(all) struct InlineAutolink {
  is_email : Bool
  link : Node[String]
}
pub fn InlineAutolink::new(Node[String]) -> Self
pub impl Eq for InlineAutolink
pub impl Show for InlineAutolink
pub impl ToJson for InlineAutolink

pub(all) struct InlineBreak {
  layout_before : Node[String]
  ty : InlineBreakType
  layout_after : Node[String]
}
pub fn InlineBreak::new(layout_before? : Node[String], layout_after? : Node[String], InlineBreakType) -> Self
pub impl Eq for InlineBreak
pub impl Show for InlineBreak
pub impl ToJson for InlineBreak

pub(all) enum InlineBreakType {
  Hard
  Soft
}
pub impl Compare for InlineBreakType
pub impl Eq for InlineBreakType
pub impl Show for InlineBreakType
pub impl ToJson for InlineBreakType
pub impl @json.FromJson for InlineBreakType

pub(all) struct InlineCodeSpan {
  backticks : Int
  code_layout : Seq[Tight]
}
pub fn InlineCodeSpan::code(Self) -> String
pub fn InlineCodeSpan::from_string(meta? : @cmark_base.Meta, String) -> Self
pub fn InlineCodeSpan::new(backticks~ : Int, Seq[Tight]) -> Self
pub impl Eq for InlineCodeSpan
pub impl Show for InlineCodeSpan
pub impl ToJson for InlineCodeSpan

pub(all) struct InlineEmphasis {
  delim : Char
  inline : Inline
}
pub fn InlineEmphasis::new(delim? : Char, Inline) -> Self
pub impl Eq for InlineEmphasis
pub impl Show for InlineEmphasis
pub impl ToJson for InlineEmphasis

pub(all) struct InlineLink {
  text : Inline
  reference : ReferenceKind
}
pub fn InlineLink::is_unsafe(String) -> Bool
pub fn InlineLink::new(Inline, ReferenceKind) -> Self
pub fn InlineLink::reference_definition(Self, Map[String, LabelDef]) -> LabelDef?
pub fn InlineLink::referenced_label(Self) -> Label?
pub impl Eq for InlineLink
pub impl Show for InlineLink
pub impl ToJson for InlineLink

pub(all) struct InlineMathSpan {
  display : Bool
  tex_layout : Seq[Tight]
}
pub fn InlineMathSpan::tex(Self) -> String
pub impl Eq for InlineMathSpan
pub impl Show for InlineMathSpan
pub impl ToJson for InlineMathSpan

pub(all) struct InlineRawHtml(Seq[Tight])
#deprecated
pub fn InlineRawHtml::inner(Self) -> Seq[Tight]
pub impl Eq for InlineRawHtml
pub impl Show for InlineRawHtml
pub impl ToJson for InlineRawHtml

pub(all) struct InlineStrikethrough(Inline)
#deprecated
pub fn InlineStrikethrough::inner(Self) -> Inline
pub impl Eq for InlineStrikethrough
pub impl Show for InlineStrikethrough
pub impl ToJson for InlineStrikethrough

pub(all) struct Label {
  meta : @cmark_base.Meta
  key : String
  text : Seq[Tight]
}
pub fn Label::compare(Self, Self) -> Int
pub fn Label::new(meta? : @cmark_base.Meta, key~ : String, Seq[Tight]) -> Self
pub fn Label::text_loc(Self) -> @cmark_base.TextLoc
pub impl Eq for Label
pub impl Show for Label
pub impl ToJson for Label

pub(all) enum LabelContext {
  Def(Label?, Label)
  Ref(LinkKind, Label, Label?)
}
pub fn LabelContext::default_resolver(Self) -> Label?

pub(all) enum LabelDef {
  LinkDef(Node[LinkDefinition])
  FootnoteDef(Node[Footnote])
}
pub impl Show for LabelDef
pub impl ToJson for LabelDef

pub(all) struct LabelResolverFn((LabelContext) -> Label?)
#deprecated
pub fn LabelResolverFn::inner(Self) -> (LabelContext) -> Label?

pub(all) struct LinkDefinition {
  layout : LinkDefinitionLayout
  label : Label?
  defined_label : Label?
  dest : Node[String]?
  title : Seq[Tight]?
}
pub fn LinkDefinition::new(layout? : LinkDefinitionLayout, label? : Label?, defined_label? : Label?, dest? : Node[String]?, title? : Seq[Tight]?) -> Self
pub impl Eq for LinkDefinition
pub impl Show for LinkDefinition
pub impl ToJson for LinkDefinition

pub(all) struct LinkDefinitionLayout {
  indent : Int
  angled_dest : Bool
  before_dest : Seq[Node[String]]
  after_dest : Seq[Node[String]]
  title_open_delim : Char
  after_title : Seq[Node[String]]
}
pub fn LinkDefinitionLayout::default() -> Self
pub fn LinkDefinitionLayout::for_dest(String) -> Self
pub impl Eq for LinkDefinitionLayout
pub impl Show for LinkDefinitionLayout
pub impl ToJson for LinkDefinitionLayout

pub(all) enum LinkKind {
  Link
  Image
}

#alias(ListItemBlock)
pub(all) struct ListItem {
  before_marker : Int
  marker : Node[String]
  after_marker : Int
  block : Block
  ext_task_marker : Node[Char]?
}
pub fn ListItem::map_block(Self, (Block) -> Block) -> Self
pub fn ListItem::new(before_marker? : Int, marker? : Node[String], after_marker? : Int, ext_task_marker~ : Node[Char]?, Block) -> Self
pub fn ListItem::normalize_block(Self) -> Self
pub impl Show for ListItem
pub impl ToJson for ListItem

pub(all) enum ListTaskStatus {
  Cancelled
  Checked
  Unchecked
  Other(Char)
}
pub fn ListTaskStatus::from_marker(Char) -> Self

pub(all) struct MapFn[A]((Mapper, A) -> A? raise MapperError)
#deprecated
pub fn[A] MapFn::inner(Self[A]) -> (Mapper, A) -> A? raise MapperError

pub(all) struct Mapper {
  inline_ext_default : MapFn[Inline]
  block_ext_default : MapFn[Block]
  inline : MapperFn[Inline]
  block : MapperFn[Block]
}
pub fn[A] Mapper::block_ext_none(Self, A) -> A? raise MapperError
pub fn[A] Mapper::delete() -> MapperResult[A]
pub fn[A] Mapper::inline_ext_none(Self, A) -> A? raise MapperError
pub fn Mapper::map_block(Self, Block) -> Block?
pub fn Mapper::map_doc(Self, Doc) -> Doc
pub fn Mapper::map_inline(Self, Inline) -> Inline?
pub fn Mapper::new(inline_ext_default? : MapFn[Inline], block_ext_default? : MapFn[Block], inline? : MapperFn[Inline], block? : MapperFn[Block]) -> Self
pub fn[A] Mapper::none(Self, A) -> MapperResult[A]
pub fn[A] Mapper::ret(A) -> MapperResult[A]

pub(all) struct MapperFn[A]((Mapper, A) -> MapperResult[A])
#deprecated
pub fn[A] MapperFn::inner(Self[A]) -> (Mapper, A) -> MapperResult[A]

pub(all) enum MapperResult[A] {
  Default
  Map(A?)
}
pub impl[A] Default for MapperResult[A]
pub impl[A : Eq] Eq for MapperResult[A]
pub impl[A : Show] Show for MapperResult[A]
pub impl[A : ToJson] ToJson for MapperResult[A]

pub(all) struct Node[A] {
  v : A
  meta : @cmark_base.Meta
}
pub fn Node::empty(meta? : @cmark_base.Meta) -> Self[String]
pub fn[A, B] Node::map(Self[A], (A) -> B) -> Self[B]
pub fn[A] Node::new(A, meta? : @cmark_base.Meta) -> Self[A]
pub impl[A : Eq] Eq for Node[A]
pub impl[A : Show] Show for Node[A]
pub impl[A : ToJson] ToJson for Node[A]

pub(all) enum ReferenceKind {
  Inline(Node[LinkDefinition])
  Ref(ReferenceLayout, Label, Label)
}
pub impl Eq for ReferenceKind
pub impl Show for ReferenceKind
pub impl ToJson for ReferenceKind

pub(all) enum ReferenceLayout {
  Collapsed
  Full
  Shortcut
}
pub impl Eq for ReferenceLayout
pub impl Show for ReferenceLayout
pub impl ToJson for ReferenceLayout
pub impl @json.FromJson for ReferenceLayout

type Seq[A]
pub fn[A] Seq::empty() -> Self[A]
pub fn[A, B] Seq::fold(Self[A], init~ : B, (B, A) -> B) -> B
pub fn[A] Seq::from_array(Array[A]) -> Self[A]
pub fn[A] Seq::from_iter(Iter[A]) -> Self[A]
pub fn[A] Seq::get(Self[A], Int) -> A?
pub fn[A] Seq::is_empty(Self[A]) -> Bool
pub fn[A] Seq::iter(Self[A]) -> Iter[A]
pub fn[A] Seq::length(Self[A]) -> Int
pub fn[A, B] Seq::map(Self[A], (A) -> B) -> Self[B]
pub fn[A] Seq::op_get(Self[A], Int) -> A
pub fn[A] Seq::op_set(Self[A], Int, A) -> Unit
pub fn[A, B] Seq::rev_fold(Self[A], init~ : B, (B, A) -> B) -> B
pub fn[A] Seq::to_array(Self[A]) -> Array[A]
pub impl[A : Eq] Eq for Seq[A]
pub impl[A : Show] Show for Seq[A]
pub impl[A : ToJson] ToJson for Seq[A]

pub(all) struct Table {
  indent : Int
  col_count : Int
  rows : Seq[(Node[TableRow], String)]
}
pub fn Table::new(indent? : Int, Seq[(Node[TableRow], String)]) -> Self
pub impl Show for Table
pub impl ToJson for Table

pub(all) enum TableAlign {
  Left
  Center
  Right
}
pub impl Show for TableAlign
pub impl ToJson for TableAlign
pub impl @json.FromJson for TableAlign

pub(all) struct TableCellLayout((String, String))
#deprecated
pub fn TableCellLayout::inner(Self) -> (String, String)
pub impl Compare for TableCellLayout
pub impl Eq for TableCellLayout
pub impl Show for TableCellLayout
pub impl ToJson for TableCellLayout

pub(all) enum TableRow {
  Header(Seq[(Inline, TableCellLayout)])
  Sep(Seq[Node[TableSep]])
  Data(Seq[(Inline, TableCellLayout)])
}
pub impl Show for TableRow
pub impl ToJson for TableRow

pub(all) struct TableSep((TableAlign?, Int))
#deprecated
pub fn TableSep::inner(Self) -> (TableAlign?, Int)
pub impl Show for TableSep
pub impl ToJson for TableSep

pub(all) struct Tight {
  blanks : String
  node : Node[String]
}
pub fn Tight::empty(meta? : @cmark_base.Meta) -> Self
pub fn Tight::list_text_loc(Seq[Self]) -> @cmark_base.TextLoc
pub fn Tight::to_string(Self) -> String
pub impl Eq for Tight
pub impl Show for Tight
pub impl ToJson for Tight

// Type aliases
pub type Blanks = String

pub type BlanksNode = Node[String]

pub type BlockBlankLine = String

pub type BlockLineBlank = Node[String]

pub type Count = Int

pub type InlineText = String

pub type LabelDefs = Map[String, LabelDef]

pub type LabelKey = String

pub type StringNode = Node[String]

// Traits

