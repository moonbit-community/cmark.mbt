// Generated using `moon info`, DON'T EDIT IT
package "moonbit-community/cmark/cmark_base"

import(
  "moonbitlang/core/json"
)

// Values
pub fn autolink_email(String, last? : Int, start? : Int) -> Int?

pub fn autolink_uri(String, last? : Int, start? : Int) -> Int?

pub let char_code_pos_none : Int

pub fn could_be_link_ref_definition(String, last~ : Int, start~ : Int) -> Bool

pub fn ext_task_marker(String, last~ : Int, start~ : Int) -> (Char, Int)?

pub let file_path_none : String

pub fn first_non_blank(String, last~ : Int, start~ : Int) -> Int

pub fn first_non_blank_in_span(String, LineSpan) -> Int

pub fn[A] first_non_blank_over_nl(next_line~ : NextLineFn[A], String, A, line~ : LineSpan, start~ : Int) -> NextLineResult?

pub fn first_non_escaped_char(Char, String, last~ : Int, start~ : Int) -> Int

pub fn last_non_blank(String, first~ : Int, start~ : Int) -> Int

pub let line_num_none : Int

pub let line_pos_none : LinePos

pub fn link_destination(String, last~ : Int, start~ : Int) -> (Bool, Int, Int)?

pub fn[A] link_label(StringBuilder, next_line~ : NextLineFn[A], String, A, line~ : LineSpan, start~ : Int) -> (LineSpan, Array[Span], Int, String)?

pub fn[A] link_title(next_line~ : NextLineFn[A], String, A, line~ : LineSpan, start~ : Int) -> (LineSpan, Array[Span], Int)?

pub fn[A] raw_html(next_line~ : NextLineFn[A], String, A, line~ : LineSpan, start~ : Int) -> (LineSpan, Array[Span], Int)?

pub fn rev_drop_spaces(String, first~ : Int, start~ : Int) -> Int

pub fn run_of(char~ : Char, String, last~ : Int, start~ : Int) -> Int

// Errors

// Types and methods
pub(all) enum FencedCodeBlockContinue {
  Close(Int, Int)
  Code
}
pub fn FencedCodeBlockContinue::new(String, fence~ : (Char, Int), last~ : Int, start~ : Int) -> Self
pub impl Show for FencedCodeBlockContinue
pub impl ToJson for FencedCodeBlockContinue

pub(all) enum HtmlBlockEndCond {
  EndStr(String)
  EndCond1
  EndBlank
  EndBlank7
}
pub impl Eq for HtmlBlockEndCond
pub impl Show for HtmlBlockEndCond
pub impl ToJson for HtmlBlockEndCond

pub(all) struct LinePos(Int, Int)


pub impl Compare for LinePos
pub impl Eq for LinePos
pub impl Show for LinePos
pub impl ToJson for LinePos
pub impl @json.FromJson for LinePos

pub(all) struct LineSpan {
  pos : LinePos
  first : Int
  last : Int
}
pub impl Compare for LineSpan
pub impl Eq for LineSpan
pub impl Show for LineSpan
pub impl ToJson for LineSpan

pub(all) enum LineType {
  AtxHeadingLine(Int, Int, Int, Int)
  BlankLine
  BlockQuoteLine
  FencedCodeBlockLine(Int, Int, (Int, Int)?)
  HtmlBlockLine(HtmlBlockEndCond)
  IndentedCodeBlockLine
  ListMarkerLine(ListType, Int)
  ParagraphLine
  SetextUnderlineLine(Int, Int)
  ThematicBreakLine(Int)
  ExtTableRow(Int)
  ExtFootnoteLabel(Array[Span], Int, String)
  Nomatch
}
pub fn LineType::atx_heading(String, last~ : Int, start~ : Int) -> Self
pub fn LineType::ext_footnote_label(StringBuilder, String, line_pos~ : LinePos, last~ : Int, start~ : Int) -> Self
pub fn LineType::ext_table_row(String, last~ : Int, start~ : Int) -> Self
pub fn LineType::fenced_code_block_start(String, last~ : Int, start~ : Int) -> Self
pub fn LineType::html_block_end(String, end_cond~ : HtmlBlockEndCond, last~ : Int, start~ : Int) -> Bool
pub fn LineType::html_block_start(String, last~ : Int, start~ : Int) -> Self
pub fn LineType::list_marker(String, last~ : Int, start~ : Int) -> Self
pub fn LineType::setext_heading_underline(String, last~ : Int, start~ : Int) -> Self
pub fn LineType::thematic_break(String, last~ : Int, start~ : Int) -> Self
pub impl Eq for LineType
pub impl Show for LineType
pub impl ToJson for LineType

pub(all) enum ListType {
  Unordered(Char)
  Ordered(Int, Char)
}
pub fn ListType::is_same_type(Self, Self) -> Bool
pub impl Eq for ListType
pub impl Show for ListType
pub impl ToJson for ListType
pub impl @json.FromJson for ListType

pub(all) struct Meta {
  id : Int
  loc : TextLoc
  extra : Error?
}
pub fn Meta::compare(Self, Self) -> Int
pub fn Meta::is_none(Self) -> Bool
pub fn Meta::new(loc? : TextLoc) -> Self
pub fn Meta::none() -> Self
pub fn Meta::to_json(Self) -> Json
pub impl Eq for Meta
pub impl Show for Meta
pub impl ToJson for Meta

pub(all) struct NextLineFn[A]((A) -> LineSpan?)
#deprecated
pub fn[A] NextLineFn::inner(Self[A]) -> (A) -> LineSpan?

pub(all) enum NextLineResult {
  ThisLine(Int)
  NextLine(LineSpan, Int)
}
pub impl Show for NextLineResult
pub impl ToJson for NextLineResult

pub(all) struct Span {
  start : Int
  span : LineSpan
}
pub impl Compare for Span
pub impl Eq for Span
pub impl Show for Span
pub impl ToJson for Span

pub(all) struct TextLoc {
  file : String
  first_ccode : Int
  last_ccode : Int
  first_line : LinePos
  last_line : LinePos
}
pub fn TextLoc::after(Self) -> Self
pub fn TextLoc::is_empty(Self) -> Bool
pub fn TextLoc::is_none(Self) -> Bool
pub fn TextLoc::none() -> Self
pub fn TextLoc::reloc(Self, Self) -> Self
pub fn TextLoc::span(Self, Self) -> Self
pub fn TextLoc::to_first(Self) -> Self
pub fn TextLoc::to_last(Self) -> Self
pub impl Compare for TextLoc
pub impl Eq for TextLoc
pub impl Show for TextLoc
pub impl ToJson for TextLoc
pub impl @json.FromJson for TextLoc

// Type aliases
pub type CharCodePos = Int

pub type FilePath = String

pub type First = Int

pub type HeadingLevel = Int

pub type Indent = Int

pub type Last = Int

pub type LineNum = Int

pub type Next = Int

// Traits

